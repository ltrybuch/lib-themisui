<h1>Fixtures</h1>

<h2>What are they about?</h2>

<p>Throughout the tests and examples you will notice references to "fixture" files. These fixtures contain sample data that is used...
<ul>
  <li>to provide data to demos</li>
  <li>to stub response data when mocking HTTP responses (both in tests and demos)</li>
  <li>to stub objects in tests</li>
</ul>

and ultimately...
<ul>
  <li>as a centralized source of truth for stubbing</li>
</ul>
Stub data can be simplified as JSON, and we initially aimed to do just that. However a minimal amount of computation/manipulation was allowed
to facilitate DRYing up of the objects.</p>

<h2>What they are not about</h2>

<p>A fixture file shoud be EXTREMELY easy to understand...it should just represent some sample data. Getting fancy with computing values is to be
avoided as much as possible. We don't want fixture data to become an additional layer of complexity when working with the codebase.

<em>As a hard rule:</em> Don't put logic in fixture files. Favour duplication over introducing logic.</p>

<h2>Conventions</h2>

<h4>Where do they live?</h4>

<p>In one place, per component: <code>myComponent/tests/fixtures</code></p>
<p>There should be one fixture file per resource e.g. <code>entries.ts</code>, <code>calendars.ts</code>.</p>

<h4><code>items</code></h4>

<p>A standardized name, rather than naming items by their nature e.g. <code>calendars</code>.</p>
<pre>
  import * as expectedEntries from "./tests/fixtures/entries";
  import * as expectedEntries from "./tests/fixtures/calendars";

  // bad
  expectedEntries.entries
  expectedCalendars.calendars

  // good
  expectedEntries.items
  expectedCalendars.items
</pre>

<h4><code>ids</code></h4>

<p>Almost always required when the retrieval of ids is needed for corresponding resources.</p>
<pre>
  describe("#getCalendarIds", function() {

    it("returns the calendar ids", function(done) {
      calendarEntryService.getCalendarIds()
        .then(function(data) {
          expect(data).toEqual(expectedCalendars.ids);
          done();
        });
    });

  });
</pre>

<h4><code>apiNestedItems</code></h4>

<p>Nests the <code>items</code> to mimic an API response whose data is nested. It is useful to encapsulate this modification
inside this file, to keep it out of the implementation.</p>
<pre>
    const apiNestedItems = {
      calendars: items
    };
</pre>

<h2>Example "Calendars" fixture</h2>

<pre>
  const items = [
    {
      id: 1,
      name: "Personal"
    },
    {
      id: 2,
      name: "Shared"
    }
  ];

  const ids = [1, 2];

  const apiNestedItems = {
    calendars: items
  };

  export {
    items,
    ids,
    apiNestedItems
  };
</pre>

<h3>Usage</h3>

<pre>
  describe("#getEntriesForCalendar", function() {

  it("returns the entries for one calendar", function(done) {
    calendarEntryService.getEntriesForCalendar(expectedEntries.oneCalendarEntriesId)
      .then(function(data) {
        expect(data).toEqual(expectedEntries.oneCalendarEntriesItems);
        done();
      });

    $httpBackend
      .expectGET("calendar_entries?calendar_id=1")
      .respond(expectedEntries.oneCalendarEntriesItems);
    $httpBackend.flush();
  });

});
</pre>

<pre>
  import * as angular from "angular";
  import { fakeResponse } from "../../../services/http-mocking.service";
  import * as expectedEntries from "../../tests/fixtures/entries";
  import * as expectedCalendars from "../../tests/fixtures/calendars";
  import SchedulerDataSource from "../../../services/scheduler-data-source.service";
  import CalendarEntriesService from "../../multipleCalendars/calendar-entries.service";

  fakeResponse(/calendars/, expectedCalendars.apiNestedItems);
  fakeResponse(/calendar_entries\?calendar_id\=1/, expectedEntries.firstCalendarEntriesItems);
  fakeResponse(/calendar_entries\?calendar_id\=2/, expectedEntries.secondCalendarEntriesItems);

  angular.module("thSchedulerDemo")
    .controller("thSchedulerDemoCtrl3", function(
      SchedulerDataSource: SchedulerDataSource,
      CalendarEntriesService: CalendarEntriesService
    ) {

      this.options = {
        dataSource: SchedulerDataSource.createDataSource({
          schema: {
            data: "entries",
            model: {
              fields: {
                end: { from: "end", type: "date" },
                id: { from: "id", type: "number" },
                start: { from: "start", type: "date" },
                title: { from: "title" },
                calendar_id: { from: "calendar_id" }
              },
              id: "id"
            }
          },
          transport: {
            read: function(e: kendo.data.DataSourceTransportOptions) {
              CalendarEntriesService.getEntriesForCalendars()
                .then(function(entries) {
                  e.success({ entries: entries });
                });
            }
          }
        }),
        date: new Date(expectedEntries.date)
      };
    });
</pre>